
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>go-wiki: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">go-wiki/wiki.go (74.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
    "encoding/json"
    "errors"
        "math"
    "fmt"
    "html/template"
    "log"
    "net/http"
    "os"
    "path/filepath"
    "regexp"
    "sort"
    "strconv"
    "strings"
    "sync"
    "time"

    "github.com/sergi/go-diff/diffmatchpatch"
    "github.com/yuin/goldmark"
)

// Constants with compile-time checks using const expressions
const (
    // Maximum size for page content to prevent memory exhaustion
    max_page_size_bytes = 1 &lt;&lt; 20 // 1MB

    // Maximum number of concurrent requests to prevent resource exhaustion
    max_concurrent_requests = 100

    // Maximum number of pages to list in directory
    max_directory_pages = 1000

    // Maximum number of versions to keep per page
    max_versions_per_page = 1000

        // 1 second cache TTL
        page_cache_ttl_ms = 1000

        max_batch_size = 10

        batch_timeout_ms = 100

        // default data directory if not specified
        default_data_dir = "data"

    // Compile-time checks using constant expressions
    _max_page_check        = uint64(max_page_size_bytes - (1 &lt;&lt; 20))     // Will fail if &gt; 1MB
    _max_versions_check    = uint64(max_versions_per_page - 1000)        // Will fail if &gt; 1000
    _max_concurrent_check  = uint64(max_concurrent_requests - 100)        // Will fail if &gt; 100
    _max_directory_check   = uint64(max_directory_pages - 1000)          // Will fail if &gt; 1000
)


// Common errors
var (
    ErrPageTooLarge   = errors.New("page content exceeds maximum allowed size")
    ErrEmptyTitle     = errors.New("page title cannot be empty")
    ErrServerBusy     = errors.New("server is at maximum capacity")
    ErrVersionTooOld  = errors.New("version number is too old")
    ErrVersionInvalid = errors.New("invalid version number")
)

// PageVersion represents a specific version of a page
type PageVersion struct {
    Content   string    `json:"content"`
    Timestamp time.Time `json:"timestamp"`
    Author    string    `json:"author"`
    Comment   string    `json:"comment"`
    Size      int64     `json:"size"`
    Version   int64     `json:"version"`
}

// Page represents a wiki page with its metadata
type Page struct {
    Title       string
    Body        template.HTML // rendered HTML content
    RawBody     string       // raw markdown content
    Size_bytes  int64        // size of raw content
    Modified_at int64        // unix timestamp
    Version     int64        // current version number
    Comment     string       // last change comment
}

type PageCache struct {
    cache sync.Map  // map[string]*Page
}


// Search result
type SearchResult struct {
    Title     string
    Snippet   string
    Relevance float64
}

// VersionMetadata stores version history information
type VersionMetadata struct {
    CurrentVersion int64                  `json:"current_version"`
    Versions      map[int64]*PageVersion `json:"versions"`
}

// VersionDiff represents the difference between two versions
type VersionDiff struct {
    OldVersion int64
    NewVersion int64
    Diffs      []DiffSegment
}

// DiffSegment represents a segment in a version diff
type DiffSegment struct {
    Type     string // "equal", "insert", "delete"
    Text     string
    Added    bool
    Removed  bool
}

// BatchOperation represents a pending page operation
type BatchOperation struct {
    Page    *Page
    Comment string
    Done    chan error // Signal completion to caller
}

// Read batching
type ReadOperation struct {
    Title   string
    Version int64
    Done    chan ReadResult
}

type ReadResult struct {
    Page *Page
    Err  error
}

// Batch processing metrics
type BatchMetrics struct {
    Processed  int64
    Errors     int64
    BatchesFull int64
    BatchesPartial int64
}

// PageBatcher handles batched page operations
type PageBatcher struct {
    operations chan BatchOperation
    readOps    chan ReadOperation
    maxBatch   int
    timeout    time.Duration
    wiki       *Wiki
    metrics    BatchMetrics
    mu         sync.RWMutex
}

// Assert that the page is valid before any operation (uses paired assertions)
func (p *Page) validate() error <span class="cov6" title="31">{
    // check title
    if p.Title == "" </span><span class="cov1" title="1">{
        return ErrEmptyTitle
    }</span>

    // Check title length - reasonable maximum for file systems
    <span class="cov6" title="30">if len(p.Title) &gt; 64 </span><span class="cov0" title="0">{
        return fmt.Errorf("title exceeds maximum length of 64 characters")
    }</span>

    // Check title characters using your existing validPath regexp
    <span class="cov6" title="30">if !validPath.MatchString("/view/" + p.Title) </span><span class="cov1" title="1">{
        return fmt.Errorf("title contains invalid characters")
    }</span>

    // Check content size
    <span class="cov6" title="29">if int64(len(p.RawBody)) &gt; max_page_size_bytes </span><span class="cov2" title="2">{
        return ErrPageTooLarge
    }</span>

    // Paired assertion: verify title and content consistency
    <span class="cov6" title="27">if len(p.RawBody) &gt; 0 &amp;&amp; p.Title == "" </span><span class="cov0" title="0">{
        return fmt.Errorf("content present but title missing")
    }</span>

    <span class="cov6" title="27">return nil</span>
}

// getDataDir returns the configured data directory or default
func getDataDir() string <span class="cov9" title="170">{
    if dir := os.Getenv("WIKI_DATA_DIR"); dir != "" </span><span class="cov9" title="170">{
        return dir
    }</span>
    <span class="cov0" title="0">return default_data_dir</span>
}

// Move from Page to Wiki
func (w *Wiki) savePage(p *Page, comment string) error <span class="cov6" title="31">{
    if err := p.validate(); err != nil </span><span class="cov3" title="4">{
        return err
    }</span>

    // Create version directory structure
    <span class="cov6" title="27">pageDir := filepath.Join(getDataDir(), "pages", p.Title)
    if err := os.MkdirAll(pageDir, 0755); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // Load or create version metadata
    <span class="cov6" title="27">metadata, err := loadVersionMetadata(p.Title)
    if err != nil </span><span class="cov0" title="0">{
        metadata = &amp;VersionMetadata{
            Versions: make(map[int64]*PageVersion),
        }
    }</span>

        <span class="cov6" title="27">p.Modified_at = time.Now().Unix()

    // Create new version
    newVersion := metadata.CurrentVersion + 1
    version := &amp;PageVersion{
        Content:   p.RawBody,
        Timestamp: time.Now(),
        Comment:   comment,
        Size:      p.Size_bytes,
        Version:   newVersion,
    }

    // Save version file
    versionFile := filepath.Join(pageDir, fmt.Sprintf("%d.md", newVersion))
    if err := os.WriteFile(versionFile, []byte(p.RawBody), 0600); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // Update metadata
    <span class="cov6" title="27">metadata.CurrentVersion = newVersion
    metadata.Versions[newVersion] = version

    // Save current version
    currentFile := filepath.Join(getDataDir(), p.Title+".md")
    if err := os.WriteFile(currentFile, []byte(p.RawBody), 0600); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // Save metadata
    <span class="cov6" title="27">if err := saveVersionMetadata(p.Title, metadata); err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    // Update search index
    <span class="cov6" title="27">w.pageIndex.Store(p.Title, p.RawBody)

    return nil</span>
}

func (w *Wiki) loadPageVersion(title string, version int64) (*Page, error) <span class="cov5" title="21">{
    if title == "" </span><span class="cov0" title="0">{
        return nil, ErrEmptyTitle
    }</span>

    // Try cache first for current versions
    <span class="cov5" title="21">if version == 0 </span><span class="cov5" title="15">{
        if cached, ok := w.pageCache.get(title); ok </span><span class="cov3" title="5">{
            return cached, nil
        }</span>
    }

    <span class="cov5" title="16">metadata, err := loadVersionMetadata(title)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    <span class="cov5" title="16">var content []byte
    if version &lt;= 0 || version == metadata.CurrentVersion </span><span class="cov4" title="11">{
        // Load current version
        content, err = os.ReadFile(filepath.Join(getDataDir(), title+".md"))
    }</span> else<span class="cov3" title="5"> {
        if version &gt; metadata.CurrentVersion </span><span class="cov0" title="0">{
            return nil, ErrVersionInvalid
        }</span>
        // Load specific version
        <span class="cov3" title="5">versionFile := filepath.Join(getDataDir(), "pages", title, fmt.Sprintf("%d.md", version))
        content, err = os.ReadFile(versionFile)</span>
    }
    <span class="cov5" title="16">if err != nil </span><span class="cov2" title="2">{
        return nil, err
    }</span>

    // Check size bounds
    <span class="cov5" title="14">if len(content) &gt; max_page_size_bytes </span><span class="cov0" title="0">{
        return nil, ErrPageTooLarge
    }</span>

    // Convert markdown to HTML
    <span class="cov5" title="14">var html_body strings.Builder
    if err := goldmark.Convert(content, &amp;html_body); err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    <span class="cov5" title="14">page := &amp;Page{
        Title:      title,
        Body:       template.HTML(html_body.String()),
        RawBody:    string(content),
        Size_bytes: int64(len(content)),
        Version:    version,
        Modified_at: time.Now().Unix(), // Add this line
    }

    if v, ok := metadata.Versions[version]; ok </span><span class="cov3" title="6">{
        page.Comment = v.Comment
        // Don't override Modified_at from metadata since we want cache to be fresh
    }</span>

    // Update search index and cache with current version only
    <span class="cov5" title="14">if version &lt;= 0 || version == metadata.CurrentVersion </span><span class="cov4" title="9">{
        w.pageIndex.Store(title, string(content))
        w.pageCache.set(page)
    }</span>

    <span class="cov5" title="14">return page, nil</span>
}

// Get version history for a page
func getPageHistory(title string) ([]*PageVersion, error) <span class="cov1" title="1">{
    metadata, err := loadVersionMetadata(title)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    <span class="cov1" title="1">history := make([]*PageVersion, 0, len(metadata.Versions))
    for _, version := range metadata.Versions </span><span class="cov2" title="3">{
        history = append(history, version)
    }</span>

    // Sort by version number descending
    <span class="cov1" title="1">sort.Slice(history, func(i, j int) bool </span><span class="cov2" title="2">{
        return history[i].Version &gt; history[j].Version
    }</span>)

    <span class="cov1" title="1">return history, nil</span>
}

// Compare two versions and generate diff
func (w *Wiki) compareVersions(title string, oldVersion, newVersion int64) (*VersionDiff, error) <span class="cov1" title="1">{
    oldPage, err := w.loadPageVersion(title, oldVersion)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    <span class="cov1" title="1">newPage, err := w.loadPageVersion(title, newVersion)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    <span class="cov1" title="1">dmp := diffmatchpatch.New()
    diffs := dmp.DiffMain(oldPage.RawBody, newPage.RawBody, true)

    segments := make([]DiffSegment, len(diffs))
    for i, diff := range diffs </span><span class="cov2" title="3">{
        segments[i] = DiffSegment{Text: diff.Text}
        switch diff.Type </span>{
        case diffmatchpatch.DiffEqual:<span class="cov1" title="1">
            segments[i].Type = "equal"</span>
        case diffmatchpatch.DiffInsert:<span class="cov1" title="1">
            segments[i].Type = "insert"
            segments[i].Added = true</span>
        case diffmatchpatch.DiffDelete:<span class="cov1" title="1">
            segments[i].Type = "delete"
            segments[i].Removed = true</span>
        }
    }

    <span class="cov1" title="1">return &amp;VersionDiff{
        OldVersion: oldVersion,
        NewVersion: newVersion,
        Diffs:      segments,
    }, nil</span>
}

// Restore a specific version
func (w *Wiki) restoreVersion(title string, version int64) error <span class="cov1" title="1">{
    oldPage, err := w.loadPageVersion(title, version)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

    <span class="cov1" title="1">page := &amp;Page{
        Title:      title,
        RawBody:    oldPage.RawBody,
        Size_bytes: oldPage.Size_bytes,
    }

    comment := fmt.Sprintf("Restored from version %d", version)
    return w.savePage(page, comment)</span>
}

// Helper functions for metadata
func loadVersionMetadata(title string) (*VersionMetadata, error) <span class="cov7" title="44">{
    metadataFile := filepath.Join(getDataDir(), "pages", title, "metadata.json")
    data, err := os.ReadFile(metadataFile)
    if err != nil </span><span class="cov5" title="18">{
        if os.IsNotExist(err) </span><span class="cov5" title="18">{
            return &amp;VersionMetadata{Versions: make(map[int64]*PageVersion)}, nil
        }</span>
        <span class="cov0" title="0">return nil, err</span>
    }

    <span class="cov6" title="26">var metadata VersionMetadata
    if err := json.Unmarshal(data, &amp;metadata); err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>
    <span class="cov6" title="26">return &amp;metadata, nil</span>
}

func saveVersionMetadata(title string, metadata *VersionMetadata) error <span class="cov6" title="27">{
    metadataFile := filepath.Join(getDataDir(), "pages", title, "metadata.json")
    data, err := json.MarshalIndent(metadata, "", "    ")
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>
    <span class="cov6" title="27">return os.WriteFile(metadataFile, data, 0600)</span>
}

// RequestLimiter implements a concurrent request limiter
type RequestLimiter struct {
    semaphore chan struct{}
}

func NewRequestLimiter() *RequestLimiter <span class="cov5" title="16">{
    return &amp;RequestLimiter{
        semaphore: make(chan struct{}, max_concurrent_requests),
    }
}</span>

func (l *RequestLimiter) Acquire() error <span class="cov10" title="263">{
    select </span>{
    case l.semaphore &lt;- struct{}{}:<span class="cov9" title="261">
        return nil</span>
    default:<span class="cov2" title="2">
        return ErrServerBusy</span>
    }
}

func (l *RequestLimiter) Release() <span class="cov7" title="61">{
    &lt;-l.semaphore
}</span>

// Wiki represents our application state
type Wiki struct {
    templates *template.Template
    limiter   *RequestLimiter
    mu        sync.RWMutex         // Protects concurrent page operations
        pageIndex sync.Map             // Used for search functionality, stores page content in memory
        batcher   *PageBatcher         // Page batching for performance
        pageCache PageCache                // Not a ptr
}

func (w *Wiki) initializeSearchIndex() error <span class="cov5" title="14">{
    // Scan the data directory for all pages
    baseDir := getDataDir()
    files, err := os.ReadDir(baseDir)
    if err != nil </span><span class="cov0" title="0">{
        return err
    }</span>

        <span class="cov5" title="14">log.Printf("Indexing pages...")
    for _, file := range files </span><span class="cov5" title="14">{
        // Only process .md files
        if !file.IsDir() &amp;&amp; strings.HasSuffix(file.Name(), ".md") </span><span class="cov0" title="0">{
            pageName := strings.TrimSuffix(file.Name(), ".md")
            content, err := os.ReadFile(filepath.Join(baseDir, file.Name()))
            if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error reading %s: %v", file.Name(), err)
                continue</span>
            }
            <span class="cov0" title="0">w.pageIndex.Store(pageName, string(content))</span>
        }
    }

        <span class="cov5" title="14">log.Printf("Page index complete")

    return nil</span>
}

func NewWiki() (*Wiki, error) <span class="cov5" title="14">{
    // Ensure data directory exists
    dataDir := getDataDir()
    if err := os.MkdirAll(filepath.Join(dataDir, "pages"), 0755); err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    // Load templates
    <span class="cov5" title="14">templates, err := template.ParseGlob("templates/*.html")
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    <span class="cov5" title="14">wiki := &amp;Wiki{
        templates: templates,
        limiter:   NewRequestLimiter(),
        pageCache: PageCache{},
    }

    // Create batcher after wiki is initialized
    wiki.batcher = NewPageBatcher(wiki, 10, 100*time.Millisecond)

    // Initialize search index
    if err := wiki.initializeSearchIndex(); err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    <span class="cov5" title="14">return wiki, nil</span>
}

// Batching

// Cache implementation
func (c *PageCache) get(title string) (*Page, bool) <span class="cov5" title="17">{
    if value, ok := c.cache.Load(title); ok </span><span class="cov4" title="7">{
        page := value.(*Page)
        // Check if cache entry is still valid
        if time.Since(time.Unix(page.Modified_at, 0)).Milliseconds() &lt; page_cache_ttl_ms </span><span class="cov3" title="6">{
            return page, true
        }</span>
        // Expired, remove from cache
        <span class="cov1" title="1">c.cache.Delete(title)</span>
    }
    <span class="cov4" title="11">return nil, false</span>
}

func (c *PageCache) set(page *Page) <span class="cov4" title="9">{
    c.cache.Store(page.Title, page)
}</span>

func NewPageBatcher(wiki *Wiki, maxBatch int, timeout time.Duration) *PageBatcher <span class="cov5" title="14">{
    if maxBatch &lt;= 0 </span><span class="cov0" title="0">{
        maxBatch = max_batch_size
    }</span>
    <span class="cov5" title="14">if timeout &lt;= 0 </span><span class="cov0" title="0">{
        timeout = batch_timeout_ms * time.Millisecond
    }</span>

    <span class="cov5" title="14">batcher := &amp;PageBatcher{
        operations: make(chan BatchOperation, maxBatch),
        readOps:    make(chan ReadOperation, maxBatch),
        maxBatch:   maxBatch,
        timeout:    timeout,
        wiki:       wiki,
    }
    go batcher.processLoop()  // Handle writes
    go batcher.processReads() // Handle reads
    return batcher</span>
}

func (b *PageBatcher) processReads() <span class="cov5" title="14">{
    batch := make([]*ReadOperation, 0, b.maxBatch)
    timer := time.NewTimer(b.timeout)

    for </span><span class="cov9" title="164">{
        select </span>{
        case op := &lt;-b.readOps:<span class="cov5" title="17">
            batch = append(batch, &amp;op)

            if len(batch) &gt;= b.maxBatch </span><span class="cov0" title="0">{
                b.processReadBatch(batch)
                batch = batch[:0]
                timer.Reset(b.timeout)
            }</span>

        case &lt;-timer.C:<span class="cov8" title="133">
            if len(batch) &gt; 0 </span><span class="cov5" title="12">{
                b.processReadBatch(batch)
                batch = batch[:0]
            }</span>
            <span class="cov8" title="133">timer.Reset(b.timeout)</span>
        }
    }
}

func (b *PageBatcher) processReadBatch(batch []*ReadOperation) <span class="cov5" title="12">{
    b.wiki.mu.RLock()
    defer b.wiki.mu.RUnlock()

    for _, op := range batch </span><span class="cov5" title="17">{
        page, err := b.wiki.loadPageVersion(op.Title, op.Version)
        op.Done &lt;- ReadResult{Page: page, Err: err}
    }</span>
}

func (b *PageBatcher) processLoop() <span class="cov5" title="14">{
    batch := make([]*BatchOperation, 0, b.maxBatch)
    timer := time.NewTimer(b.timeout)

    for </span><span class="cov9" title="153">{
        select </span>{
        case op := &lt;-b.operations:<span class="cov3" title="6">
            batch = append(batch, &amp;op)

                        // Process if batch is full
            if len(batch) &gt;= b.maxBatch </span><span class="cov0" title="0">{
                b.processBatch(batch)
                batch = batch[:0]
                timer.Reset(b.timeout)

                b.mu.Lock()
                b.metrics.BatchesFull++
                b.mu.Unlock()
            }</span>

        case &lt;-timer.C:<span class="cov8" title="133">
            if len(batch) &gt; 0 </span><span class="cov2" title="2">{
                                // Process partial batch on timeout
                b.processBatch(batch)
                batch = batch[:0]

                b.mu.Lock()
                b.metrics.BatchesPartial++
                b.mu.Unlock()
            }</span>
            <span class="cov8" title="133">timer.Reset(b.timeout)</span>
        }
    }
}

func (b *PageBatcher) processBatch(batch []*BatchOperation) <span class="cov2" title="2">{
    // Lock once for the entire batch
    b.wiki.mu.Lock()
    defer b.wiki.mu.Unlock()

    for _, op := range batch </span><span class="cov3" title="6">{
        err := b.wiki.savePage(op.Page, op.Comment)
        op.Done &lt;- err

        b.mu.Lock()
        b.metrics.Processed++
        if err != nil </span><span class="cov1" title="1">{
            b.metrics.Errors++
        }</span>
        <span class="cov3" title="6">b.mu.Unlock()</span>
    }
}

// HTTP Handlers

func (w *Wiki) viewHandler(writer http.ResponseWriter, request *http.Request, title string) <span class="cov5" title="13">{
    if err := w.limiter.Acquire(); err != nil </span><span class="cov0" title="0">{
        http.Error(writer, err.Error(), http.StatusServiceUnavailable)
        return
    }</span>
    <span class="cov5" title="13">defer w.limiter.Release()

    if title == "Directory" </span><span class="cov0" title="0">{
        w.serveDirectory(writer)
        return
    }</span>

    // Get version from query params
    <span class="cov5" title="13">version := int64(0)
    if v := request.URL.Query().Get("version"); v != "" </span><span class="cov0" title="0">{
        var err error
        version, err = strconv.ParseInt(v, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
            http.Error(writer, "Invalid version number", http.StatusBadRequest)
            return
        }</span>
    }

    // Use batched read
    <span class="cov5" title="13">result := make(chan ReadResult, 1)
    w.batcher.readOps &lt;- ReadOperation{
        Title:   title,
        Version: version,
        Done:  result,
    }

    // Wait for result
    readResult := &lt;-result
    if readResult.Err != nil </span><span class="cov1" title="1">{
        if os.IsNotExist(readResult.Err) </span><span class="cov1" title="1">{
            http.Redirect(writer, request, "/edit/"+title, http.StatusFound)
            return
        }</span>
        <span class="cov0" title="0">http.Error(writer, readResult.Err.Error(), http.StatusInternalServerError)
        return</span>
    }

    <span class="cov5" title="12">w.renderTemplate(writer, "view", readResult.Page)</span>
}

func (w *Wiki) editHandler(writer http.ResponseWriter, request *http.Request, title string) <span class="cov2" title="2">{
    if err := w.limiter.Acquire(); err != nil </span><span class="cov0" title="0">{
        http.Error(writer, err.Error(), http.StatusServiceUnavailable)
        return
    }</span>
    <span class="cov2" title="2">defer w.limiter.Release()

    result := make(chan ReadResult, 1)
    w.batcher.readOps &lt;- ReadOperation{
        Title:   title,
        Version: 0, // Always get latest for edit
        Done:  result,
    }

    readResult := &lt;-result
    if readResult.Err != nil &amp;&amp; !os.IsNotExist(readResult.Err) </span><span class="cov0" title="0">{
        http.Error(writer, readResult.Err.Error(), http.StatusInternalServerError)
        return
    }</span>

    <span class="cov2" title="2">if readResult.Err != nil </span><span class="cov1" title="1">{
        // Page doesn't exist, create new
        readResult.Page = &amp;Page{Title: title}
    }</span>

    <span class="cov2" title="2">w.renderTemplate(writer, "edit", readResult.Page)</span>
}

func (w *Wiki) diffHandler(writer http.ResponseWriter, request *http.Request, title string) <span class="cov2" title="2">{
    if err := w.limiter.Acquire(); err != nil </span><span class="cov0" title="0">{
        http.Error(writer, err.Error(), http.StatusServiceUnavailable)
        return
    }</span>
    <span class="cov2" title="2">defer w.limiter.Release()

    oldVersion, err := strconv.ParseInt(request.URL.Query().Get("old"), 10, 64)
    if err != nil </span><span class="cov1" title="1">{
        http.Error(writer, "Invalid old version", http.StatusBadRequest)
        return
    }</span>

    <span class="cov1" title="1">newVersion, err := strconv.ParseInt(request.URL.Query().Get("new"), 10, 64)
    if err != nil </span><span class="cov0" title="0">{
        http.Error(writer, "Invalid new version", http.StatusBadRequest)
        return
    }</span>

    // Read both versions in parallel
    <span class="cov1" title="1">oldResult := make(chan ReadResult, 1)
    newResult := make(chan ReadResult, 1)

    w.batcher.readOps &lt;- ReadOperation{
        Title:   title,
        Version: oldVersion,
        Done:  oldResult,
    }
    w.batcher.readOps &lt;- ReadOperation{
        Title:   title,
        Version: newVersion,
        Done:  newResult,
    }

    // Wait for both results
    oldReadResult := &lt;-oldResult
    newReadResult := &lt;-newResult

    if oldReadResult.Err != nil </span><span class="cov0" title="0">{
        http.Error(writer, oldReadResult.Err.Error(), http.StatusInternalServerError)
        return
    }</span>
    <span class="cov1" title="1">if newReadResult.Err != nil </span><span class="cov0" title="0">{
        http.Error(writer, newReadResult.Err.Error(), http.StatusInternalServerError)
        return
    }</span>

    // Generate diff
    <span class="cov1" title="1">dmp := diffmatchpatch.New()
    diffs := dmp.DiffMain(oldReadResult.Page.RawBody, newReadResult.Page.RawBody, true)

    segments := make([]DiffSegment, len(diffs))
    for i, diff := range diffs </span><span class="cov3" title="4">{
        segments[i] = DiffSegment{Text: diff.Text}
        switch diff.Type </span>{
        case diffmatchpatch.DiffEqual:<span class="cov2" title="2">
            segments[i].Type = "equal"</span>
        case diffmatchpatch.DiffInsert:<span class="cov1" title="1">
            segments[i].Type = "insert"
            segments[i].Added = true</span>
        case diffmatchpatch.DiffDelete:<span class="cov1" title="1">
            segments[i].Type = "delete"
            segments[i].Removed = true</span>
        }
    }

    <span class="cov1" title="1">data := struct {
        Title string
        Diff  *VersionDiff
    }{title, &amp;VersionDiff{
        OldVersion: oldVersion,
        NewVersion: newVersion,
        Diffs:      segments,
    }}

    w.renderTemplate(writer, "diff", data)</span>
}

func (w *Wiki) saveHandler(writer http.ResponseWriter, request *http.Request, title string) <span class="cov4" title="7">{
    if request.Method != http.MethodPost </span><span class="cov1" title="1">{
        http.Error(writer, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }</span>

    <span class="cov3" title="6">if err := w.limiter.Acquire(); err != nil </span><span class="cov0" title="0">{
        http.Error(writer, err.Error(), http.StatusServiceUnavailable)
        return
    }</span>
    <span class="cov3" title="6">defer w.limiter.Release()

    if err := request.ParseForm(); err != nil </span><span class="cov0" title="0">{
        http.Error(writer, err.Error(), http.StatusBadRequest)
        return
    }</span>

    <span class="cov3" title="6">body := request.FormValue("body")
    comment := request.FormValue("comment")
    page := &amp;Page{Title: title, RawBody: body}

    done := make(chan error, 1)
    w.batcher.operations &lt;- BatchOperation{
        Page:    page,
        Comment: comment,
        Done:    done,
    }

    // Wait for batch operation to complete
        // Don't need direct mutex lock as batching system handles synchronization
    if err := &lt;-done; err != nil </span><span class="cov1" title="1">{
        http.Error(writer, err.Error(), http.StatusInternalServerError)
        return
    }</span>

    <span class="cov3" title="5">http.Redirect(writer, request, "/view/"+title, http.StatusFound)</span>
}

func (w *Wiki) historyHandler(writer http.ResponseWriter, request *http.Request, title string) <span class="cov1" title="1">{
    if err := w.limiter.Acquire(); err != nil </span><span class="cov0" title="0">{
        http.Error(writer, err.Error(), http.StatusServiceUnavailable)
        return
    }</span>
    <span class="cov1" title="1">defer w.limiter.Release()

    w.mu.RLock()
    history, err := getPageHistory(title)
    w.mu.RUnlock()

    if err != nil </span><span class="cov0" title="0">{
        http.Error(writer, err.Error(), http.StatusInternalServerError)
        return
    }</span>

    <span class="cov1" title="1">data := struct {
        Title   string
        History []*PageVersion
    }{title, history}

    w.renderTemplate(writer, "history", data)</span>
}

func (w *Wiki) restoreHandler(writer http.ResponseWriter, request *http.Request, title string) <span class="cov1" title="1">{
    if request.Method != http.MethodPost </span><span class="cov0" title="0">{
        http.Error(writer, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }</span>

    <span class="cov1" title="1">if err := w.limiter.Acquire(); err != nil </span><span class="cov0" title="0">{
        http.Error(writer, err.Error(), http.StatusServiceUnavailable)
        return
    }</span>
    <span class="cov1" title="1">defer w.limiter.Release()

    version, err := strconv.ParseInt(request.URL.Query().Get("version"), 10, 64)
    if err != nil </span><span class="cov0" title="0">{
        http.Error(writer, "Invalid version", http.StatusBadRequest)
        return
    }</span>

    <span class="cov1" title="1">w.mu.Lock()
    err = w.restoreVersion(title, version)
    w.mu.Unlock()

    if err != nil </span><span class="cov0" title="0">{
        http.Error(writer, err.Error(), http.StatusInternalServerError)
        return
    }</span>

    <span class="cov1" title="1">http.Redirect(writer, request, "/view/"+title, http.StatusFound)</span>
}

func (w *Wiki) serveDirectory(writer http.ResponseWriter) <span class="cov1" title="1">{
    w.mu.RLock()
    defer w.mu.RUnlock()

    pages := make(map[string]bool) // Use map to avoid duplicates
    baseDir := getDataDir()

    // Debug: print the directory we're scanning
    log.Printf("Scanning directory: %s", baseDir)

    files, err := os.ReadDir(baseDir)
    if err != nil </span><span class="cov0" title="0">{
        log.Printf("Error reading directory: %v", err)
        http.Error(writer, err.Error(), http.StatusInternalServerError)
        return
    }</span>

    <span class="cov1" title="1">for _, file := range files </span><span class="cov3" title="4">{
        // Skip directories and non-.md files
        name := file.Name()
        if file.IsDir() || !strings.HasSuffix(name, ".md") </span><span class="cov1" title="1">{
            continue</span>
        }

        <span class="cov2" title="3">pageName := strings.TrimSuffix(name, ".md")
        pages[pageName] = true
        log.Printf("Found page: %s", pageName)

        if len(pages) &gt;= max_directory_pages </span><span class="cov0" title="0">{
            http.Error(writer, "too many pages", http.StatusInternalServerError)
            return
        }</span>
    }

    // Convert map to sorted slice
    <span class="cov1" title="1">pageList := make([]string, 0, len(pages))
    for page := range pages </span><span class="cov2" title="3">{
        pageList = append(pageList, page)
    }</span>
    <span class="cov1" title="1">sort.Strings(pageList)

    log.Printf("Final page list: %v", pageList)

    data := struct {
        Pages []string
    }{pageList}

    w.renderTemplate(writer, "directory", data)</span>
}

func (w *Wiki) renderTemplate(writer http.ResponseWriter, tmpl string, data interface{}) <span class="cov5" title="19">{
    err := w.templates.ExecuteTemplate(writer, tmpl+".html", data)
    if err != nil </span><span class="cov0" title="0">{
        http.Error(writer, err.Error(), http.StatusInternalServerError)
    }</span>
}

// More restrictive path validation following TigerStyle
var validPath = regexp.MustCompile(`^/(edit|save|view|history|diff|restore)/([a-zA-Z][a-zA-Z0-9_-]{0,63})$`)

func (w *Wiki) makeHandler(fn func(http.ResponseWriter, *http.Request, string)) http.HandlerFunc <span class="cov6" title="27">{
    return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov6" title="27">{
        matches := validPath.FindStringSubmatch(request.URL.Path)
        if matches == nil </span><span class="cov1" title="1">{
            http.NotFound(writer, request)
            return
        }</span>
        <span class="cov6" title="26">fn(writer, request, matches[2])</span>
    }
}

func (w *Wiki) searchHandler(writer http.ResponseWriter, request *http.Request) <span class="cov2" title="2">{
    if err := w.limiter.Acquire(); err != nil </span><span class="cov0" title="0">{
        http.Error(writer, err.Error(), http.StatusServiceUnavailable)
        return
    }</span>
    <span class="cov2" title="2">defer w.limiter.Release()

    query := request.URL.Query().Get("q")
    if query == "" </span><span class="cov1" title="1">{
        w.renderTemplate(writer, "search", nil)
        return
    }</span>

    <span class="cov1" title="1">w.mu.RLock()
    results := w.searchPages(query)
    w.mu.RUnlock()

    data := struct {
        Query    string
        Results  []SearchResult
        Count    int
    }{
        Query:    query,
        Results:  results,
        Count:    len(results),
    }

    w.renderTemplate(writer, "search", data)</span>
}

func (w *Wiki) searchPages(query string) []SearchResult <span class="cov1" title="1">{
    query = strings.ToLower(query)
    var results []SearchResult

    w.pageIndex.Range(func(key, value interface{}) bool </span><span class="cov2" title="3">{
        title := key.(string)
        content := value.(string)

        // Simple relevance scoring based on title and content matches
        relevance := 0.0

        titleLower := strings.ToLower(title)
        // Exact title match gets highest score
        if titleLower == query </span><span class="cov0" title="0">{
            relevance += 5.0
        }</span> else<span class="cov2" title="3"> if strings.Contains(titleLower, query) </span><span class="cov1" title="1">{
            relevance += 2.0
        }</span>

        // Content matches
        <span class="cov2" title="3">contentLower := strings.ToLower(content)
        if strings.Contains(contentLower, query) </span><span class="cov2" title="2">{
            relevance += 1.0

            // Create a snippet of the matching content
            index := strings.Index(contentLower, query)
            start := math.Max(0, float64(index-50))
            end := math.Min(float64(len(content)), float64(index+len(query)+50))

            snippet := content[int(start):int(end)]
            if start &gt; 0 </span><span class="cov0" title="0">{
                snippet = "..." + snippet
            }</span>
            <span class="cov2" title="2">if end &lt; float64(len(content)) </span><span class="cov0" title="0">{
                snippet = snippet + "..."
            }</span>

            <span class="cov2" title="2">if relevance &gt; 0 </span><span class="cov2" title="2">{
                results = append(results, SearchResult{
                    Title:     title,
                    Snippet:   snippet,
                    Relevance: relevance,
                })
            }</span>
        }
        <span class="cov2" title="3">return true</span>
    })

    // Sort results by relevance
    <span class="cov1" title="1">sort.Slice(results, func(i, j int) bool </span><span class="cov1" title="1">{
        return results[i].Relevance &gt; results[j].Relevance
    }</span>)

    <span class="cov1" title="1">return results</span>
}

func main() <span class="cov0" title="0">{
    // Initialize wiki
    wiki, err := NewWiki()
    if err != nil </span><span class="cov0" title="0">{
        log.Fatal(err)
    }</span>

    // Setup routes
    <span class="cov0" title="0">http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
        if r.URL.Path != "/" </span><span class="cov0" title="0">{
            http.NotFound(w, r)
            return
        }</span>
        <span class="cov0" title="0">http.Redirect(w, r, "/view/FrontPage", http.StatusFound)</span>
    })
    <span class="cov0" title="0">http.HandleFunc("/view/", wiki.makeHandler(wiki.viewHandler))
    http.HandleFunc("/edit/", wiki.makeHandler(wiki.editHandler))
    http.HandleFunc("/save/", wiki.makeHandler(wiki.saveHandler))
    http.HandleFunc("/history/", wiki.makeHandler(wiki.historyHandler))
    http.HandleFunc("/diff/", wiki.makeHandler(wiki.diffHandler))
    http.HandleFunc("/restore/", wiki.makeHandler(wiki.restoreHandler))
        http.HandleFunc("/search", wiki.searchHandler)

    port := ":8080"
    log.Printf("Starting wiki server on %s", port)
    log.Fatal(http.ListenAndServe(port, nil))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
